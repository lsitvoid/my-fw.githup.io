<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>胡言乱语</title>
     <link rel="icon" type="image/png" href="../tupian/xiaot.avif">
    <link rel="stylesheet" href="css/style2.1.css">
</head>
<body>
    <!-- 左侧卡片区域 -->
    <div class="card-container">
        <div class="tab-nav" id="tabNav">
            <!-- <div class="nav-arrow left-arrow" onclick="scrollNav(-1)">‹</div> -->
            <!-- <div class="tab-item active" onclick="openTab(event, 'tab1')">页面1</div>
            <div class="tab-item" onclick="openTab(event, 'tab2')">页面2</div>
            <div class="tab-item" onclick="openTab(event, 'tab3')">页面3</div>
            <div class="tab-item">页面4</div>
            <div class="tab-item">页面5</div> -->
            <!-- <div class="nav-arrow right-arrow" onclick="scrollNav(1)">›</div> -->
            <div class="tab-item active" data-target="peace">世界和平</div>
            <div class="tab-item" data-target="hello">你好世界</div>
            <div class="tab-item" data-target="page3">红黑树</div>
            <div class="tab-item" data-target="page4">2，4，1</div>
            <div class="tab-item" data-target="page5">页面5</div>
        </div>
        
        <!-- <div class="card-content">
             卡片内容 -->
            <!--<h2>卡片内容区域</h2>
            <p>这里放置具体内容...</p>
        </div> -->

        <!-- <div id="tab1" class="tab-content active">
                <h2>卡片 1</h2>
                <p>这里是第一个卡片的内容...</p>
            </div>
            <div id="tab2" class="tab-content">
                <h2>卡片 2</h2>
                <p>这里是第二个卡片的内容...</p>
            </div>
            <div id="tab3" class="tab-content">
                <h2>卡片 3</h2>
                <p>这里是第三个卡片的内容...</p>
            </div> -->
    <!-- </div> -->

    <div class="card-content">
            <!-- 内容区块 -->
            <div id="peace" class="content-section active">
                <h2>世界和平主题</h2>
                <p>构建人类命运共同体，促进全球和平发展...</p>
                <img src="tupian/5.jpg" alt="图片" style="width: 100%; margin-top: 15px; border-radius: 8px;">
            </div>
 
            <div id="hello" class="content-section">
                <h2>你好世界</h2>
                <p>探索编程世界，从Hello World开始！</p>
                <pre><code>print("Hello World!")</code></pre>
                <img src="tupian/4.jpg" alt="图片" style="width: 60%; margin: 15px 0; border-radius: 8px;">
            </div>
 
            <div id="page3" class="content-section">
                <h2>红黑树</h2>
                <p><p>
            <hr>
           红黑树是一种自平衡的二叉搜索树，它在每个节点上增加了一个存储位来表示节点的颜色，可以是红色或黑色。通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。<br>
           以下是红黑树的实现原理：<br>

<h3>基本性质</h3>
节点颜色：每个节点要么是红色，要么是黑色。<br>
根节点：根节点是黑色。<br>
叶子节点：所有叶子节点（NIL节点，空节点）是黑色。<br>
红色节点的子节点：如果一个节点是红色的，则它的两个子节点都是黑色的。<br>
路径上的黑色节点数量：对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。<br>
<h3>插入操作</h3>
插入新节点：新插入的节点初始为红色，因为插入红色节点不会破坏性质5（路径上的黑色节点数量），但可能会破坏性质4（红色节点的子节点是黑色）。<br>
调整树结构：插入新节点后，需要通过旋转和颜色调整来恢复红黑树的性质。具体调整情况如下：<br>
情况1：新节点的父节点是黑色，直接插入，不破坏任何性质。<br>
情况2：新节点的父节点是红色，且叔叔节点（父节点的兄弟节点）也是红色。将父节点和叔叔节点染成黑色，祖父节点染成红色，然后以祖父节点为新的当前节点继续调整。<br>
情况3：新节点的父节点是红色，叔叔节点是黑色，且新节点是父节点的右孩子。以父节点为支点进行左旋，然后转换为情况4。<br>
情况4：新节点的父节点是红色，叔叔节点是黑色，且新节点是父节点的左孩子。将父节点染成黑色，祖父节点染成红色，然后以祖父节点为支点进行右旋。<br>
<h3>删除操作</h3>
删除节点：首先按照二叉搜索树的删除方法删除节点，如果删除的是红色节点，不会破坏红黑树的性质；如果删除的是黑色节点，可能会破坏性质5，需要进行调整。<br>
调整树结构：删除黑色节点后，需要通过旋转和颜色调整来恢复红黑树的性质。具体调整情况较为复杂，这里不详细展开。<br>
<h3>旋转操作</h3>
左旋：以某个节点为支点进行左旋，会将该节点的右子节点提升为父节点，该节点变为其右子节点的左子节点，同时调整相关节点的颜色。<br>
右旋：以某个节点为支点进行右旋，会将该节点的左子节点提升为父节点，该节点变为其左子节点的右子节点，同时调整相关节点的颜色。<br>
通过以上的插入、删除和旋转操作，红黑树能够在动态插入和删除节点的过程中，始终保持其平衡性质，从而保证了插入、删除和查找操作的时间复杂度都是O(log n)。<br>
<h3>插入实现</h3>
# 定义颜色常量，RED 用 True 表示，BLACK 用 False 表示，方便后续对节点颜色进行标记<br>
RED = True<br>
BLACK = False<br>

# 定义红黑树的节点类<br>
class Node:<br>
&emsp;&ensp;# 初始化方法，创建节点时需要传入键、值和颜色<br>
&emsp;&ensp;def __init__(self, key, value, color):<br>
&emsp;&ensp;&emsp;&ensp;# 节点存储的键<br>
&emsp;&ensp;&emsp;&ensp;self.key = key<br>
&emsp;&ensp;&emsp;&ensp;# 节点存储的值<br>
&emsp;&ensp;&emsp;&ensp;self.value = value<br>
&emsp;&ensp;&emsp;&ensp;# 左子节点，初始为 None<br>
&emsp;&ensp;&emsp;&ensp;self.left = None<br>
&emsp;&ensp;&emsp;&ensp;# 右子节点，初始为 None<br>
&emsp;&ensp;&emsp;&ensp;self.right = None<br>
&emsp;&ensp;&emsp;&ensp;# 节点的颜色<br>
&emsp;&ensp;&emsp;&ensp;self.color = color<br>
<br>
# 判断节点是否为红色<br>
def is_red(node):<br>
&emsp;&ensp;# 如果节点为空，说明不存在，返回 False<br>
&emsp;&ensp;if node is None:<br>
&emsp;&ensp;&emsp;&ensp;return False<br>
&emsp;&ensp;# 节点存在且颜色为 RED（即 True），返回 True<br>
&emsp;&ensp;return node.color == RED<br>
<br>
# 左旋操作，用于调整树的结构以维持红黑树的平衡<br>
def rotate_left(h):<br>
&emsp;&ensp;# 保存当前节点 h 的右子节点为 x<br>
&emsp;&ensp;x = h.right<br>
&emsp;&ensp;# 将 x 的左子节点作为 h 的右子节点<br>
&emsp;&ensp;h.right = x.left<br>
&emsp;&ensp;# 将 h 作为 x 的左子节点<br>
&emsp;&ensp;x.left = h<br>
&emsp;&ensp;# x 继承 h 的颜色<br>
&emsp;&ensp;x.color = h.color<br>
&emsp;&ensp;# h 变为红色<br>
&emsp;&ensp;h.color = RED<br>
&emsp;&ensp;# 返回旋转后的根节点 x<br>
&emsp;&ensp;return x<br>
<br>
# 右旋操作，同样用于调整树的结构以维持红黑树的平衡<br>
def rotate_right(h):<br>
&emsp;&ensp;# 保存当前节点 h 的左子节点为 x<br>
&emsp;&ensp;x = h.left<br>
&emsp;&ensp;# 将 x 的右子节点作为 h 的左子节点<br>
&emsp;&ensp;h.left = x.right<br>
&emsp;&ensp;# 将 h 作为 x 的右子节点<br>
&emsp;&ensp;x.right = h<br>
&emsp;&ensp;# x 继承 h 的颜色<br>
&emsp;&ensp;x.color = h.color<br>
&emsp;&ensp;# h 变为红色<br>
&emsp;&ensp;h.color = RED<br>
&emsp;&ensp;# 返回旋转后的根节点 x<br>
&emsp;&ensp;return x<br>
<br>
# 颜色翻转操作，当出现不符合红黑树规则的颜色分布时使用<br>
def flip_colors(h):<br>
&emsp;&ensp;# 当前节点 h 变为红色<br>
&emsp;&ensp;h.color = RED<br>
&emsp;&ensp;# h 的左子节点变为黑色<br>
&emsp;&ensp;h.left.color = BLACK<br>
&emsp;&ensp;# h 的右子节点变为黑色<br>
&emsp;&ensp;h.right.color = BLACK<br>
&emsp;&ensp;# 返回颜色调整后的节点 h<br>
&emsp;&ensp;return h<br>
<br>
# 插入操作，向红黑树中插入一个键值对<br>
def insert(root, key, value):<br>
&emsp;&ensp;# 内部递归函数，用于实际执行插入操作<br>
&emsp;&ensp;def _insert(h, key, value):<br>
&emsp;&ensp;&emsp;&ensp;# 如果当前节点 h 为空，创建一个新的红色节点并返回<br>
&emsp;&ensp;&emsp;&ensp;if h is None:<br>
&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;return Node(key, value, RED)<br>
&emsp;&ensp;&emsp;&ensp;# 如果插入的键小于当前节点的键，递归插入到左子树<br>
&emsp;&ensp;&emsp;&ensp;if key < h.key:<br>
&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;h.left = _insert(h.left, key, value)<br>
&emsp;&ensp;&emsp;&ensp;# 如果插入的键大于当前节点的键，递归插入到右子树<br>
&emsp;&ensp;&emsp;&ensp;elif key > h.key:<br>
&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;h.right = _insert(h.right, key, value)<br>
&emsp;&ensp;&emsp;&ensp;# 如果插入的键等于当前节点的键，更新该节点的值<br>
&emsp;&ensp;&emsp;&ensp;else:<br>
&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;h.value = value<br>
<br>
&emsp;&ensp;&emsp;&ensp;# 如果右子节点为红色，左子节点为黑色，进行左旋操作<br>
&emsp;&ensp;&emsp;&ensp;if is_red(h.right) and not is_red(h.left):<br>
&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;h = rotate_left(h)<br>
&emsp;&ensp;&emsp;&ensp;# 如果左子节点为红色，且左子节点的左子节点也为红色，进行右旋操作<br>
&emsp;&ensp;&emsp;&ensp;if is_red(h.left) and is_red(h.left.left):<br>
&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;h = rotate_right(h)<br>
&emsp;&ensp;&emsp;&ensp;# 如果左子节点和右子节点都为红色，进行颜色翻转操作<br>
&emsp;&ensp;&emsp;&ensp;if is_red(h.left) and is_red(h.right):<br>
&emsp;&ensp;&emsp;&ensp;&emsp;&ensp;h = flip_colors(h)<br>
<br>
&emsp;&ensp;&emsp;&ensp;# 返回插入后的当前节点<br>
&emsp;&ensp;&emsp;&ensp;return h<br>
<br>
&emsp;&ensp;# 调用内部递归函数进行插入操作<br>
&emsp;&ensp;root = _insert(root, key, value)<br>
&emsp;&ensp;# 确保根节点始终为黑色<br>
&emsp;&ensp;root.color = BLACK<br>
&emsp;&ensp;# 返回插入后的根节点<br>
&emsp;&ensp;return root<br>
<br>

 
以下是调用示例及注释：<br>
 <br>
# 初始化红黑树的根节点为 None，表示空树<br>
root = None<br>
# 向红黑树中插入键为 1，值为 'one' 的节点<br>
root = insert(root, 1, 'one')<br>
# 向红黑树中插入键为 2，值为 'two' 的节点<br>
root = insert(root, 2, 'two')<br>
# 向红黑树中插入键为 3，值为 'three' 的节点<br>
root = insert(root, 3, 'three')<br>
<br>
红黑树是一种自平衡的二叉搜索树，在许多场景下都有出色的表现，但在某些特定情况下，也有一些数据结构可能更适合，不能简单地说有绝对比红黑树更好的数据结构，以下是一些对比：<br>
AVL树<br>
优点：AVL树是最早被发明的自平衡二叉搜索树，它的平衡条件更为严格，能保证树的高度始终保持在O(log n)，因此在查找操作上比红黑树更高效，时间复杂度为O(log n)。<br>
缺点：由于AVL树的平衡条件严格，在插入和删除操作时，可能需要进行更多的旋转操作来维持平衡，这使得插入和删除操作的时间复杂度虽然也是O(log n)，但实际的常数因子可能比红黑树大，所以在插入和删除操作频繁的场景下，性能可能不如红黑树。<br>
B树和B+树<br>
优点：B树和B+树是多叉树，它们的每个节点可以存储多个键值对，这使得它们在处理大量数据时，能够减少磁盘I/O次数，提高数据的读写效率。在数据库系统和文件系统中，B树和B+树被广泛应用于索引结构。<br>
缺点：B树和B+树的结构相对复杂，插入、删除和查找操作的实现难度较大。而且，由于它们的节点存储多个键值对，在某些情况下，可能会导致空间利用率不高。<br>
跳表<br>
优点：跳表是一种随机化的数据结构，它通过在链表的基础上增加多层索引来提高查找效率。跳表的插入、删除和查找操作的平均时间复杂度都是O(log n)，并且实现起来相对简单。此外，跳表还支持范围查询，这在一些应用场景中非常有用。<br>
缺点：跳表的空间复杂度为O(n)，相比于红黑树等数据结构，可能需要更多的空间来存储索引信息。而且，跳表的性能依赖于随机数的生成，如果随机数生成不均匀，可能会导致跳表的性能下降。<br>
综上所述，不同的数据结构有不同的特点和适用场景，需要根据具体的应用需求来选择合适的数据结构。如果对查找性能要求极高，且插入和删除操作较少，AVL树可能是更好的选择；如果需要处理大量数据，并且需要减少磁盘I/O次数，B树和B+树可能更适合；如果需要实现简单，并且支持范围查询，跳表是一个不错的选择。而红黑树则在插入、删除和查找操作的综合性能上表现出色，是一种非常通用的数据结构。<br>
<br>
红黑树，它在许多场景下都有广泛的应用，具有以下优点和缺点：<br>
优点<br>
高效的插入、删除和查找操作：红黑树通过对节点进行着色和旋转操作，保证了树的高度始终保持在O(log n)，因此插入、删除和查找操作的时间复杂度都是O(log n)，在处理大量数据时，性能表现良好。<br>
内存占用较少：与其他平衡二叉搜索树相比，红黑树的节点只需要额外存储一个颜色信息，不需要像AVL树那样存储平衡因子等更多的信息，因此在内存占用方面相对较少。<br>
支持有序遍历：作为二叉搜索树的一种，红黑树可以方便地进行中序遍历，从而得到有序的元素序列，这在许多应用中是非常有用的，比如实现有序集合、有序映射等。<br>
缺点<br>
实现复杂：红黑树的插入、删除操作需要考虑多种情况，并且需要进行节点的着色和旋转操作来维持树的平衡，实现起来相对复杂，代码量也比较大。<br>
不适合范围查询：虽然红黑树可以进行范围查询，但由于其结构的特点，范围查询的效率相对较低，需要遍历多个节点才能找到满足条件的元素。<br>
对缓存不友好：红黑树的节点在内存中可能不是连续存储的，这会导致缓存命中率较低，从而影响性能。在某些对缓存性能要求较高的场景下，可能需要考虑其他数据结构。<br>
        </p></p>
            </div>
 
            <div id="page4" class="content-section">
                <h2>关于241一个简单的语言</h2>
                <p>我们可以定义如下：
            1. 使用这三个数字的不同组合来表示不同的指令。
            2. 由于数字只有三个，我们可以考虑使用位置或重复次数来编码。
但是，由于用户只给了“241”这三个数字，实际上我们需要用这三个数字的序列来构建语言。<br>
我们可以这样设计：<br>
指令集由多个指令组成，每个指令由2、4、1的序列构成，每个指令有固定的长度（比如每个指令由3个数字组成。<br>
000: 空操作（但我们的数字只有2,4,1，所以不能用0，因此我们可以用连续的三个数字）<br>
我们可以定义一些基本指令：<br>
241: 表示停止（HALT）<br>
242: 表示加法<br>
244: 表示减法<br>
212: 表示从栈顶取值（假设我们使用栈机）<br>
等等。<br><br>
但这样定义比较随意，而且没有明显的规律。我们可以考虑另一种方式：每个指令由一个操作码和操作数组成。由于数字只有三个，我们可以用不同的数字组合表示操作码，操作数同样由这三种数字构成。<br>
我们可以将三个数字映射为三进制：<br>
1 -> 0<br>
2 -> 1<br>
4 -> 2<br>
这样，每个数字都可以表示三进制中的一位。那么，三个数字组合起来就可以表示一个三进制数（范围是0到26，因为3^3=27）。
这样我们就可以定义27条指令（从000到222，分别对应三进制0到26）。但是，我们也可以用一个或多个三进制数字组成指令，但考虑到每个指令需要统一长度，我们就用三个数字表示一个指令（即一个三进制三位数）。<br>
然后，我们可以为每条指令赋予意义，例如：<br>
000 (即111): 空指令（NOP）<br>
001 (即112): 加法（ADD）<br>
002 (即114): 减法（SUB）<br>
010 (即121): 乘法（MUL）<br>
011 (即122): 除法（DIV）<br>
等等<br><br>
本人头脑有限<br>
</p>
            </div>
 
            <div id="page5" class="content-section">
                <h2>页面5内容</h2>
                <p>这里是页面5的预留内容...</p>
            </div>
        </div>
    </div>

    <!-- 右侧个人信息栏 -->
    <div class="profile-container">
        <img src="../tupian/169959361.jpg" alt="头像" class="avatar">
        <h2 style="text-align: center;">LIST</h2>
        
        <div class="social-links">
            <a href="https://space.bilibili.com/" target="_blank">
                <img src="https://www.bilibili.com/favicon.ico" alt="B站">
            </a>
            <a href="https://github.com/" target="_blank">
                <img src="https://github.com/favicon.ico" alt="GitHub">
            </a>
            <a href="indexdh.html" target="_blank">
                <img src="tupian/16pic_8952312_b.jpg" alt="QQ"> 
            </a>
        </div>

        <div class="feature-box">
            <a href="indexyouxi.html">
            <h3>游戏开发项目</h3>
            <p>一个使用godot开发的2D卡牌游戏</p>
            </a>
        </div>
        <div class="feature-box">
            <h3>功能2</h3>
            <p>功能描述...</p>
        </div>
        <div class="feature-box">
            <h3>功能3</h3>
            <p>功能描述...</p>
        </div>
    </div>

    <script>

         // 初始化内容切换
        document.querySelectorAll('.tab-item').forEach(tab => {
            tab.addEventListener('click', () => {
                // 更新标签样式
                document.querySelector('.tab-item.active')?.classList.remove('active');
                tab.classList.add('active');
 
                // 获取目标内容ID
                const targetId = tab.dataset.target;
 
                // 隐藏所有内容
                document.querySelectorAll('.content-section').forEach(content => {
                    content.classList.remove('active');
                });
 
                // 显示目标内容
                document.getElementById(targetId).classList.add('active');
            });
        });

        // // 标签切换功能
        // function openTab(evt, tabName) {
        //     const tabContents = document.getElementsByClassName("tab-content");
        //     const tabBtns = document.getElementsByClassName("tab-item");
            
        //     for (let content of tabContents) {
        //         content.classList.remove("active");
        //     }
        //     for (let btn of tabBtns) {
        //         btn.classList.remove("active");
        //     }

        //     document.getElementById(tabName).classList.add("active");
        //     evt.currentTarget.classList.add("active");
        // }

        // // 动态添加标签
        // let tabCount = 3;
        // function addTab() {
        //     tabCount++;
        //     const tabHeader = document.getElementById('tabHeader');
        //     const newTabBtn = document.createElement('button');
        //     newTabBtn.className = 'tab-item';
        //     newTabBtn.textContent = tabCount;
        //     newTabBtn.onclick = function(e) { openTab(e, `tab${tabCount}`) };
            
        //     const newTabContent = document.createElement('div');
        //     newTabContent.id = `tab${tabCount}`;
        //     newTabContent.className = 'tab-content';
        //     newTabContent.innerHTML = `<h2>卡片 ${tabCount}</h2><p>这里是第${tabCount}个卡片的内容...</p>`;

        //     tabHeader.appendChild(newTabBtn);
        //     document.querySelector('.tab-section').appendChild(newTabContent);
        // }

        // 导航滚动功能
        function scrollNav(direction) {
            const nav = document.getElementById('tabNav');
            const scrollAmount = direction * 200; // 每次滚动200px
            nav.scrollLeft += scrollAmount;
        }

        // 可选：添加触摸滑动支持（移动端）
        let touchStartX = 0;
        document.getElementById('tabNav').addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
        });

        document.getElementById('tabNav').addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].clientX;
            const diff = touchStartX - touchEndX;
            if (Math.abs(diff) > 50) {
                scrollNav(diff > 0 ? -1 : 1);
            }
        });
    </script>
</body>
</html>

